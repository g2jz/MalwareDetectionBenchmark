# Supress Sklearn models version mismatch warning
import warnings
warnings.filterwarnings(action='ignore', category=UserWarning)


# Imports
import numpy as np
from scipy import interpolate
import pickle
import signal
import os
import sys
# Plotting
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import matplotlib.patches as mpatches
from matplotlib.lines import Line2D
from adjustText import adjust_text


# GLOBAL VARIABLES

# Paths
plot_folder = './Double-Box-Plots/'
pickle_filename = '../NestedCV/Results/Results_FINAL_Intr.pkl'


# PLOT CONFIGS

# Use LaTeX text in plots (Symbols)
plt.rc('text', usetex=True)
plt.rc('text.latex', preamble=r'\usepackage{wasysym} \usepackage{amssymb}')


# UTILS

# Ctrl + C
def sigintHandler(sig, frame):
    
    print("\nSaliendo...\n")
    sys.exit(1)
    
signal.signal(signal.SIGINT, sigintHandler)


# Check plot results folder
def checkFolder():
    
    # Check if plot folder exists
    if not os.path.exists(plot_folder):
        os.mkdir(plot_folder)    


# Load results pickle
def loadPickle(filename):
    
    # Load pickle
    with open(filename, 'rb') as f:
        results = pickle.load(f)
    
        
    return results


# Extract data from pickle results  
def extractData(results):
    
    # Extract model acronyms from dictionary
    model_acronyms = results['model_acronyms']
    
    # Create lists to store results
    bacc = list()
    fit_times = list()
    predict_times = list()
    interpretability = list()
    
    # Extract needed results to lists
    for model in results['model_acronyms']:
        bacc.append(results['nested_score'][model]['bacc'])
        fit_times.append(results['nested_score'][model]['fit_time'])
        predict_times.append(results['nested_score'][model]['predict_time'])
        interpretability.append(results['nested_score'][model]['interpretability'])
    
    
    # Calculate total times
    total_times = [x + y for (x,y) in zip(fit_times, predict_times)] 
        
    # Convert lists to np array
    fit_times = np.array(fit_times)
    predict_times = np.array(predict_times)
    total_times = np.array(total_times)
    bacc = np.array(bacc)

    
    return model_acronyms, fit_times, predict_times, total_times, bacc, interpretability


# PLOT FUNCTIONS

# Define each double box
def boxplot_2d(x, y, ax, whis=1.5, color='k', name = ''):
    
    # Define limits
    xlimits = [np.percentile(x, q) for q in (25, 50, 75)]
    ylimits = [np.percentile(y, q) for q in (25, 50, 75)]

    # Define box
    box = Rectangle(
        (xlimits[0],ylimits[0]),
        (xlimits[2]-xlimits[0]),
        (ylimits[2]-ylimits[0]),
        ec = color,
        fc = color,
        zorder=0,
        alpha=0.3
    )
    ax.add_patch(box)

    # Define X median
    vline = Line2D(
        [xlimits[1],xlimits[1]],[ylimits[0],ylimits[2]],
        color=color,
        zorder=1
    )
    ax.add_line(vline)

    # Define Y median
    hline = Line2D(
        [xlimits[0],xlimits[2]],[ylimits[1],ylimits[1]],
        color=color,
        zorder=1
    )
    ax.add_line(hline)

    # Define central point
    ax.plot([xlimits[1]],[ylimits[1]], color=color, marker='o')

    # Define x-whiskers
    iqr = xlimits[2]-xlimits[0]

    # Left line
    left = np.min(x[x > xlimits[0]-whis*iqr])
    whisker_line = Line2D(
        [left, xlimits[0]], [ylimits[1],ylimits[1]],
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_line)
    
    whisker_bar = Line2D(
        [left, left], [ylimits[0],ylimits[2]],
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_bar)

    # Right line
    right = np.max(x[x < xlimits[2]+whis*iqr])
    whisker_line = Line2D(
        [right, xlimits[2]], [ylimits[1],ylimits[1]],
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_line)
    
    whisker_bar = Line2D(
        [right, right], [ylimits[0],ylimits[2]],
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_bar)

    # Define y-whisker
    iqr = ylimits[2]-ylimits[0]

    # Bottom line
    bottom = np.min(y[y > ylimits[0]-whis*iqr])
    whisker_line = Line2D(
        [xlimits[1],xlimits[1]], [bottom, ylimits[0]], 
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_line)
    whisker_bar = Line2D(
        [xlimits[0],xlimits[2]], [bottom, bottom], 
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_bar)

    # Top line
    top = np.max(y[y < ylimits[2]+whis*iqr])
    whisker_line = Line2D(
        [xlimits[1],xlimits[1]], [top, ylimits[2]], 
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_line)
    whisker_bar = Line2D(
        [xlimits[0],xlimits[2]], [top, top], 
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_bar)


    return xlimits[1], ylimits[1]


# Check interpretability of a model based on index and return color
def checkInterpretability(index, interpretability, colors):
    
    # Extract actual interpretability from dict    
    actualInterp = interpretability[index]
    
    # Define color for each combination of interpretability
    if(actualInterp[0]):
        if(actualInterp[1]):
            color = colors[0]
        else:
            color = colors[1]
    else:
        if(actualInterp[1]):
            color = colors[2]
        else:
            color = colors[3]


    return color


# Define annotation tyoe
def annotate(ax, model_acronym, xlabel, ylabel, xytext):
    
    # Annotation properties 
    ax.annotate(model_acronym.upper(), 
        xy=(xlabel, ylabel), 
        xycoords='data',
        xytext=xytext,
        textcoords='offset points',
        arrowprops=dict(arrowstyle="->",
                        connectionstyle="arc3,rad=.2"))
 

# Annotate labels in points with offset
def annotations(ax, model_acronyms, xlabels, ylabels, xytexts):
    
    # Annotate each point with text and offset
    for model_acronym, xlabel, ylabel, xytext in zip(model_acronyms, xlabels, ylabels, xytexts):
        annotate(ax, model_acronym, xlabel, ylabel, xytext)


# Annotate fit time plot
def fitAnnotations(ax, model_acronyms, xlabels, ylabels):
    
    xytexts = [
        
        # SVC
        (0, -30),
            
        # DT           
        (0, 40),

        # RF
        (20, 10),

        # ERF
        (-50, -20),

        # GBM
        (0, 20),

        # MLP
        (0, -30),

        # AB
        (0, -30),

        # GNB
        (10, -30),
            
        # ELM          
        (10, -30),

        # EDRVFL
        (30, 0),

        # LGBM
        (-50, 5),

        # SR
        (-10, 30),

        # GPL
        (-20, 40),

        # XGB
        (30, 0),

        # BLS
        (0, -30),

        # SCN
        (0, -30),

        # KNN
        (0, 20)
    ]
   
    annotations(ax, model_acronyms, xlabels, ylabels, xytexts)


# Annotate predict time plot
def predictAnnotations(ax, model_acronyms, xlabels, ylabels):
    
    xytexts = [

        # SVC
        (0, -30),
            
        # DT           
        (0, -40),

        # RF
        (-10, -30),

        # ERF
        (30, 20),

        # GBM
        (-10, -30),

        # MLP
        (-30, -40),

        # AB
        (30, 0),

        # GNB
        (20, -20),
            
        # ELM          
        (10, -30),

        # EDRVFL
        (30, 0),

        # LGBM
        (-30, -30),

        # SR
        (30, 0),

        # GPL
        (30, 20),

        # XGB
        (20, 0),

        # BLS
        (20, -30),

        # SCN
        (20, 30),

        # KNN
        (-10, 30)
    ]
   
    annotations(ax, model_acronyms, xlabels, ylabels, xytexts)


# Plot double-box plot
def plotDoubleBox(model_acronyms, times, bacc, interpretability, timeLabel, figsize):
    
    # Figure
    fig = plt.figure(figsize=figsize)

    #Create axes
    ax = plt.axes(xscale='log')
    
    # Define plot labels
    plt.title('Balanced Accuracy vs ' + timeLabel + ' Time' + ' vs Interpretability',fontsize=20)
    plt.xlabel('Efficiency (' + timeLabel + ' Time' + ', Seconds)')
    plt.ylabel('Performance (Balanced Accuracy)',fontsize=20)
    
    # Define colors
    colors = ['#66c2a5', '#a6d854', '#8da0cb', '#fc8d62']

    # Create central points lists
    xlabels = list()
    ylabels = list()
    
    # Iterate over models
    for i in range(len(model_acronyms)):
        
        #Plot model
        xlabel, ylabel = boxplot_2d(times[i],
                                    bacc[i],
                                    ax=ax, 
                                    whis=1, 
                                    color=checkInterpretability(i, interpretability, colors), 
                                    name = model_acronyms[i])
        
        # Append central points to list
        xlabels.append(xlabel)
        ylabels.append(ylabel)


    # Color labels
    ss_patch = mpatches.Patch(color=colors[0], label=r'$\fullmoon \square$')
    sn_patch = mpatches.Patch(color=colors[1], label=r'$\fullmoon \blacksquare$')
    ns_patch = mpatches.Patch(color=colors[2], label=r'$\newmoon \square$')
    nn_patch = mpatches.Patch(color=colors[3], label=r'$\newmoon \blacksquare$')

    # Plot legend
    plt.legend(handles=[ss_patch, sn_patch, ns_patch, nn_patch], loc=0, frameon=True)
    
    # Annotate plot
    if timeLabel == 'Fit':
        fitAnnotations(ax, model_acronyms, xlabels, ylabels)
    elif timeLabel == 'Predict':
        predictAnnotations(ax, model_acronyms, xlabels, ylabels)

    
    # Save plot to pdf
    plt.savefig(plot_folder + 'bacc-vs-' + timeLabel.lower() + '-vs-intr' + '.pdf')
    
    # Clear plot
    plt.clf()
    

# Plot three plots with different times
def allPlots(model_acronyms, fit_times, predict_times, total_times, bacc, interpretability):
    
    # Plot acc, fit time and interpretability results
    plotDoubleBox(model_acronyms, fit_times, bacc, interpretability, 'Fit', (7, 5))
    
    # Plot acc, fit time and interpretability results
    plotDoubleBox(model_acronyms, predict_times, bacc, interpretability, 'Predict', (7, 5))
    
    # Plot acc, fit time and interpretability results
    #plotDoubleBox(model_acronyms, total_times, bacc, interpretability, 'Total', (7, 5))
    
    
# MAIN
if __name__ == '__main__':

    # Check folder
    checkFolder()
    
    # Load results pickle
    results = loadPickle(pickle_filename)
    
    # Extract data from results pickle
    model_acronyms, fit_times, predict_times, total_times, bacc, interpretability = extractData(results)
    
    # Plot double-box plots
    allPlots(model_acronyms, fit_times, predict_times, total_times, bacc, interpretability)