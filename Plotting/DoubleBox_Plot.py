# -*- coding: utf-8 -*-
"""
Created on Wed Apr 13 15:26:04 2022

@author: 106380
"""
from string import ascii_lowercase, digits
import pickle
from matplotlib import pyplot as plt
from matplotlib.patches import Rectangle
from matplotlib.lines import Line2D
import matplotlib.patches as mpatches

import numpy as np

plt.rc('text', usetex=True)

def boxplot_2d(x,y, ax, whis=1.5, color='k', name = ''):
    # Define limits
    xlimits = [np.percentile(x, q) for q in (25, 50, 75)]
    ylimits = [np.percentile(y, q) for q in (25, 50, 75)]

    # Define box
    box = Rectangle(
        (xlimits[0],ylimits[0]),
        (xlimits[2]-xlimits[0]),
        (ylimits[2]-ylimits[0]),
        ec = color,
        fc = color,
        zorder=0,
        alpha=0.3
    )
    ax.add_patch(box)

    # Define X median
    vline = Line2D(
        [xlimits[1],xlimits[1]],[ylimits[0],ylimits[2]],
        color=color,
        zorder=1
    )
    ax.add_line(vline)

    # Define Y median
    hline = Line2D(
        [xlimits[0],xlimits[2]],[ylimits[1],ylimits[1]],
        color=color,
        zorder=1
    )
    ax.add_line(hline)

    # Define central point
    ax.plot([xlimits[1]],[ylimits[1]], color=color, marker='o')

    ##the x-whisker
    ##defined as in matplotlib boxplot:
    ##As a float, determines the reach of the whiskers to the beyond the
    ##first and third quartiles. In other words, where IQR is the
    ##interquartile range (Q3-Q1), the upper whisker will extend to
    ##last datum less than Q3 + whis*IQR). Similarly, the lower whisker
    ####will extend to the first datum greater than Q1 - whis*IQR. Beyond
    ##the whiskers, data are considered outliers and are plotted as
    ##individual points. Set this to an unreasonably high value to force
    ##the whiskers to show the min and max values. Alternatively, set this
    ##to an ascending sequence of percentile (e.g., [5, 95]) to set the
    ##whiskers at specific percentiles of the data. Finally, whis can
    ##be the string 'range' to force the whiskers to the min and max of
    ##the data.
    iqr = xlimits[2]-xlimits[0]

    ##left
    left = np.min(x[x > xlimits[0]-whis*iqr])
    whisker_line = Line2D(
        [left, xlimits[0]], [ylimits[1],ylimits[1]],
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_line)
    whisker_bar = Line2D(
        [left, left], [ylimits[0],ylimits[2]],
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_bar)

    ##right
    right = np.max(x[x < xlimits[2]+whis*iqr])
    whisker_line = Line2D(
        [right, xlimits[2]], [ylimits[1],ylimits[1]],
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_line)
    whisker_bar = Line2D(
        [right, right], [ylimits[0],ylimits[2]],
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_bar)

    ##the y-whisker
    iqr = ylimits[2]-ylimits[0]

    ##bottom
    bottom = np.min(y[y > ylimits[0]-whis*iqr])
    whisker_line = Line2D(
        [xlimits[1],xlimits[1]], [bottom, ylimits[0]], 
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_line)
    whisker_bar = Line2D(
        [xlimits[0],xlimits[2]], [bottom, bottom], 
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_bar)

    ##top
    top = np.max(y[y < ylimits[2]+whis*iqr])
    whisker_line = Line2D(
        [xlimits[1],xlimits[1]], [top, ylimits[2]], 
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_line)
    whisker_bar = Line2D(
        [xlimits[0],xlimits[2]], [top, top], 
        color = color,
        zorder = 1
    )
    ax.add_line(whisker_bar)

    ##outliers
    # mask = (x<left)|(x>right)|(y<bottom)|(y>top)
    # ax.scatter(
    #     x[mask],y[mask],
    #     facecolors='none', edgecolors=color
    # )
    
    ax.annotate(name,xy=(xlimits[1],ylimits[1]),xytext=(1.01*xlimits[1],0.99*ylimits[1]))

def paint_plot(model_names, num_models, times, acc):
    #Create figure and axes
    fig = plt.figure()
    ax = plt.axes()

    # Define colors
    colors = ['#66c2a5','#fc8d62','#8da0cb']

    # Associate interpretability with colors TODO
    
    
    # Iterate over models
    for i in range(num_models):
        # Transparency TODO
        transparency = np.random.choice([0,1,2])
        
        #Plot model
        boxplot_2d(times[i],
                   acc[i],
                   ax=ax, 
                   whis=1, 
                   color=colors[transparency], 
                   name = model_names[i])

    # Color labels
    s_patch = mpatches.Patch(color=colors[0], label='Simulatable')
    d_patch = mpatches.Patch(color=colors[1], label='Decomposable')
    at_patch = mpatches.Patch(color=colors[2], label='Algorithmically transparent')

    # Plot legend
    plt.legend(handles=[s_patch, d_patch, at_patch], loc=0, frameon=True)

    # Plot X and Y label
    plt.xlabel('Efficiency (training time, seconds)',fontsize=20)
    plt.ylabel('Performance (accuracy, \%)',fontsize=20)
    
    # Show plot
    plt.show()

if __name__ == '__main__':
    # Filename
    filename = './Results/Results.pkl'
    
    # Load pickle
    with open(filename, 'rb') as f:
        results = pickle.load(f)
    
    # Extract data from dictionary
    model_names = results['model_names']
    num_models = len(results['model_names'])
    times = list()
    acc = list()
    for i in results['model_acronyms']:
        times.append(results['nested_score'][i]['fit_time'])
        acc.append(results['nested_score'][i]['bacc'])
    
    # Convert to np array
    times = np.array(times)
    acc = np.array(acc)
    
    # Plot
    paint_plot(model_names, num_models, times, acc)