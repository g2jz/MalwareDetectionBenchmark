# Supress Sklearn models version mismatch warning
import warnings
warnings.filterwarnings(action='ignore', category=UserWarning)


# Imports
import os
import signal
import pickle
from scipy import interpolate
import numpy as np
# Plotting
import matplotlib.pyplot as plt
from adjustText import adjust_text


# GLOBAL VARIABLES

# Paths
plot_folder = './Bacc-Time-Plots/'
pickle_filename = '../NestedCV/Results/Results_FINAL.pkl'


# UTILS

# Ctrl + C
def handler(sig, frame):
    print("\nSaliendo...\n")
    exit(1)
    
signal.signal(signal.SIGINT, handler)


# Check plot results folder
def checkFolder():
    
    # Check if plots folder exists
    if not os.path.exists(plot_folder):
        os.mkdir(plot_folder)    


# Loads results pickle
def loadPickle(filename):
    
    # Check if filename exists
    if os.path.exists(filename):
        
        # Load Pickle
        with open(filename, 'rb') as file:
            results = pickle.load(file)
        
        # Return unpickled results
        return results
    
    
    # If file does not exist raise exception
    else:
        raise Exception('Results pickle not found')


# PLOT FUNCTIONS

# Extract needed data from dict
def extractData(results):
    
    # Create lists to save results
    model_acronyms = results['model_acronyms']
    bacc = list()
    fit_times = list()
    predict_times = list()
    
    # Extract needed results to lists
    for model in model_acronyms:
        bacc.append(np.array(results['nested_score'][model]['bacc']).mean())
        fit_times.append(np.array(results['nested_score'][model]['fit_time']).mean())
        predict_times.append(np.array(results['nested_score'][model]['predict_time']).mean())
        
    # Calculate total times
    total_times = [x + y for (x,y) in zip(fit_times, predict_times)]
        
        
    return model_acronyms, fit_times, predict_times, total_times, bacc

# Define annotation type
def annotate(ax, model_acronym, xlabel, ylabel, xytext):
    
    # Annotation properties
    ax.annotate(model_acronym.upper(), 
        xy=(xlabel, ylabel), 
        xycoords='data',
        xytext=xytext,
        textcoords='offset points',
        arrowprops=dict(arrowstyle="->",
                        connectionstyle="arc3,rad=.2"))
 

# Annotate labels in points with offset
def annotations(ax, model_acronyms, xlabels, ylabels, xytexts):
    
    # Annotate each point with text and offset
    for model_acronym, xlabel, ylabel, xytext in zip(model_acronyms, xlabels, ylabels, xytexts):
        annotate(ax, model_acronym, xlabel, ylabel, xytext)


# Annotate fit time plot   
def fitAnnotations(ax, model_acronyms, xlabels, ylabels):
    
    # Text to point offsets in fit time plot
    xytexts = [
        
        # SVC
        (0, -30),
            
        # DT           
        (0, 40),

        # RF
        (20, 0),

        # ERF
        (-50, -20),

        # GBM
        (0, 20),

        # MLP
        (0, -30),

        # AB
        (0, -30),

        # GNB
        (10, 30),
            
        # ELM          
        (10, -30),

        # EDRVFL
        (30, 0),

        # LGBM
        (-50, 5),

        # SR
        (-10, 30),

        # GPL
        (-20, 40),

        # XGB
        (30, 0),

        # BLS
        (0, -30),

        # SCN
        (0, -30),

        # KNN
        (0, 20)
    ]
   
    # Annotate plot
    annotations(ax, model_acronyms, xlabels, ylabels, xytexts)


# Annotate predict time plot
def predictAnnotations(ax, model_acronyms, xlabels, ylabels):
    
    # Text to point offsets in predict time plot
    xytexts = [

        # SVC
        (0, -30),
            
        # DT           
        (0, -40),

        # RF
        (0, -30),

        # ERF
        (30, 10),

        # GBM
        (-10, -30),

        # MLP
        (-30, -40),

        # AB
        (30, 0),

        # GNB
        (20, 20),
            
        # ELM          
        (10, -30),

        # EDRVFL
        (30, 0),

        # LGBM
        (-30, -30),

        # SR
        (30, 0),

        # GPL
        (30, 20),

        # XGB
        (20, 0),

        # BLS
        (20, -30),

        # SCN
        (20, 30),

        # KNN
        (-10, 30)
    ]
   
    # Annotate plot
    annotations(ax, model_acronyms, xlabels, ylabels, xytexts)


# Annotate total time plot
def totalAnnotations(ax, model_acronyms, xlabels, ylabels):
    
    # Text to point offsets in total time plot
    xytexts = [

        # SVC
        (0, -30),
            
        # DT           
        (20, -40),

        # RF
        (30, 0),

        # ERF
        (-40, -20),

        # GBM
        (-30, -30),

        # MLP
        (-20, -40),

        # AB
        (30, 0),

        # GNB
        (20, 20),
            
        # ELM          
        (10, -30),

        # EDRVFL
        (30, 0),

        # LGBM
        (-60, 0),

        # SR
        (-40, 0),

        # GPL
        (-30, 20),

        # XGB
        (20, 0),

        # BLS
        (20, -30),

        # SCN
        (20, 30),

        # KNN
        (0, 30)
    ]
   
    # Annotate plot
    annotations(ax, model_acronyms, xlabels, ylabels, xytexts)

    
# Plot models accuracy vs time
def plotTimeAcc(model_acronyms, times, bacc, timeLabel):
     
    # Set figure size   
    fig = plt.figure(figsize=(8, 5))
    
    #Create axes
    ax = plt.axes(xscale='log')
    
    # Define plot labels
    plt.title('Balanced Accuracy vs ' + timeLabel + ' Time')
    plt.xlabel(timeLabel + ' Time (s)')
    plt.ylabel('Balanced Accuracy')
    
    # Define scatter plot
    plt.scatter(times, bacc)
    
    # Annotate plots
    if timeLabel == 'Fit':
        fitAnnotations(ax, model_acronyms, times, bacc)
    elif timeLabel == 'Predict':
        predictAnnotations(ax, model_acronyms, times, bacc)
    elif timeLabel == 'Total':
        totalAnnotations(ax, model_acronyms, times, bacc)
    
    
    # Save figure to pdf
    plt.savefig(plot_folder + 'bacc-vs-' + timeLabel.lower() + '.pdf')
    
    # Clear plot
    plt.clf()
   

# Plot three plots with different times
def allPlots(model_acronyms, fit_times, predict_times, total_times, bacc):
    
    # Plot acc and fit time results
    plotTimeAcc(model_acronyms, fit_times, bacc, 'Fit')
    
    # Plot acc and predict time results
    plotTimeAcc(model_acronyms, predict_times, bacc, 'Predict')
    
    # Plot acc and total time results
    plotTimeAcc(model_acronyms, total_times, bacc, 'Total')
    
  
# MAIN
if __name__ == "__main__":
    
    # Check folder
    checkFolder()
    
    # Load result data
    results = loadPickle(pickle_filename)
    
    # Extract data from pickle
    model_acronyms, fit_times, predict_times, total_times, bacc = extractData(results)
    
    # Save all plots to pdf
    allPlots(model_acronyms, fit_times, predict_times, total_times, bacc)